// -----------------------------------------------------------------------
// <copyright file="CommandsEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Text;

using Strategos.Generators.Helpers;
using Strategos.Generators.Models;
using Strategos.Generators.Polyfills;

namespace Strategos.Generators.Emitters;

/// <summary>
/// Emits Wolverine command records for a workflow.
/// </summary>
internal static class CommandsEmitter
{
    /// <summary>
    /// Generates the command records source code for the given workflow model.
    /// </summary>
    /// <param name="model">The workflow model containing command information.</param>
    /// <returns>The generated C# source code for the command records.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);
        FileHeaderHelper.AppendUsings(sb, "System", "System.CodeDom.Compiler");

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Start workflow command
        EmitStartCommand(sb, model);

        // For each PHASE, generate Start and Execute commands:
        // 1. Start{Phase}Command - lightweight internal routing (Saga → Saga)
        // 2. Execute{Phase}Command - legacy format for backwards compatibility
        // Phase names may include loop prefix (e.g., "SpecialistExecution_SelectSpecialist")
        foreach (var stepName in model.StepNames)
        {
            sb.AppendLine();
            EmitStartStepCommand(sb, model, stepName);

            sb.AppendLine();
            EmitExecuteCommand(sb, model, stepName);
        }

        // For each unique STEP TYPE, generate Worker command (deduplicated):
        // Execute{StepType}WorkerCommand - worker dispatch with state (Saga → Worker)
        // Worker commands use unprefixed step type names since handlers are per-type
        var emittedWorkerCommands = new HashSet<string>(StringComparer.Ordinal);
        if (model.Steps is not null)
        {
            foreach (var step in model.Steps)
            {
                if (emittedWorkerCommands.Add(step.StepName))
                {
                    sb.AppendLine();
                    EmitExecuteWorkerCommand(sb, model, step.StepName);
                }
            }
        }
        else
        {
            // Fallback for models without Step collection - use phase names
            foreach (var stepName in model.StepNames)
            {
                sb.AppendLine();
                EmitExecuteWorkerCommand(sb, model, stepName);
            }
        }

        // For loop exit branch steps, generate worker commands
        if (model.Loops is not null)
        {
            foreach (var loop in model.Loops)
            {
                if (loop.BranchOnExit is not null)
                {
                    foreach (var branchCase in loop.BranchOnExit.Cases)
                    {
                        foreach (var stepName in branchCase.StepNames)
                        {
                            if (emittedWorkerCommands.Add(stepName))
                            {
                                sb.AppendLine();
                                EmitExecuteWorkerCommand(sb, model, stepName);
                            }
                        }
                    }
                }
            }
        }

        // For failure handler steps, generate worker commands
        // These use the simple naming pattern (not namespaced by handler ID)
        // to support unified step handling across main flow and failure paths
        if (model.FailureHandlers is not null)
        {
            foreach (var handler in model.FailureHandlers)
            {
                foreach (var stepName in handler.StepNames)
                {
                    if (emittedWorkerCommands.Add(stepName))
                    {
                        sb.AppendLine();
                        EmitExecuteWorkerCommand(sb, model, stepName);
                    }
                }
            }
        }

        // For fork path steps and join steps, generate worker commands
        // Fork paths contain steps that execute in parallel and need worker commands
        if (model.Forks is not null)
        {
            foreach (var fork in model.Forks)
            {
                // Generate worker commands for fork path steps
                foreach (var path in fork.Paths)
                {
                    foreach (var stepName in path.StepNames)
                    {
                        if (emittedWorkerCommands.Add(stepName))
                        {
                            sb.AppendLine();
                            EmitExecuteWorkerCommand(sb, model, stepName);
                        }
                    }
                }

                // Generate worker command for join step
                if (!string.IsNullOrEmpty(fork.JoinStepName) && emittedWorkerCommands.Add(fork.JoinStepName))
                {
                    sb.AppendLine();
                    EmitExecuteWorkerCommand(sb, model, fork.JoinStepName);
                }
            }
        }

        // For branch case steps, generate Start, Execute, and Worker commands
        // Branch cases contain steps that execute conditionally based on discriminator
        if (model.Branches is not null)
        {
            // Track underlying step names (not phase names) from main step loop
            // Phase names may have loop prefixes (e.g., TargetLoop_VerifyVetoWithResearchStep)
            // but branch case steps use underlying step names (e.g., VerifyVetoWithResearchStep)
            // This prevents duplicate command records
            var processedStepNames = new HashSet<string>(StringComparer.Ordinal);
            foreach (var phaseName in model.StepNames)
            {
                // Extract base step name from phase name (handles loop prefixes)
                // e.g., "TargetLoop_VerifyVetoStep" → "VerifyVetoStep"
                var baseStepName = ExtractBaseStepName(phaseName);
                processedStepNames.Add(baseStepName);
            }

            foreach (var branch in model.Branches)
            {
                // Determine if this branch is inside a loop
                // If so, we need to generate prefixed Start/Execute commands
                var loopPrefix = branch.LoopPrefix;

                foreach (var branchCase in branch.Cases)
                {
                    foreach (var stepName in branchCase.StepNames)
                    {
                        // Only emit Start and Execute commands if NOT already in main step loop
                        if (!processedStepNames.Contains(stepName))
                        {
                            // Apply loop prefix for Start/Execute commands if branch is inside a loop
                            var commandStepName = loopPrefix is not null
                                ? $"{loopPrefix}_{stepName}"
                                : stepName;

                            sb.AppendLine();
                            EmitStartStepCommand(sb, model, commandStepName);

                            sb.AppendLine();
                            EmitExecuteCommand(sb, model, commandStepName);
                        }

                        // Worker commands always use BASE step name since handlers are per-type
                        if (emittedWorkerCommands.Add(stepName))
                        {
                            sb.AppendLine();
                            EmitExecuteWorkerCommand(sb, model, stepName);
                        }
                    }
                }
            }
        }

        // For each approval point, generate approval-related commands
        if (model.HasApprovalPoints)
        {
            EmitApprovalCommands(sb, model, model.ApprovalPoints!, emittedWorkerCommands);
        }

        // For each fork, generate fork/join commands
        if (model.HasForks)
        {
            EmitForkCommands(sb, model, model.Forks!);
        }

        // For each failure handler, generate trigger and step commands
        if (model.HasFailureHandlers)
        {
            EmitFailureHandlerCommands(sb, model, model.FailureHandlers!);
        }

        return sb.ToString();
    }

    private static void EmitApprovalCommands(
        StringBuilder sb,
        WorkflowModel model,
        IReadOnlyList<ApprovalModel> approvals,
        HashSet<string> emittedWorkerCommands)
    {
        foreach (var approval in approvals)
        {
            // Resume command with ApprovalDecision enum
            sb.AppendLine();
            EmitResumeApprovalCommand(sb, model, approval);

            // Request approval event for integration handler
            sb.AppendLine();
            EmitRequestApprovalEvent(sb, model, approval);

            // Set pending approval command for saga state tracking
            sb.AppendLine();
            EmitSetPendingApprovalCommand(sb, model, approval);

            // Timeout command if escalation is configured
            if (approval.HasEscalation)
            {
                sb.AppendLine();
                EmitTimeoutCommand(sb, model, approval);
            }

            // Worker commands for rejection steps
            if (approval.RejectionSteps is not null)
            {
                foreach (var step in approval.RejectionSteps)
                {
                    if (emittedWorkerCommands.Add(step.StepName))
                    {
                        sb.AppendLine();
                        EmitExecuteWorkerCommand(sb, model, step.StepName);
                    }
                }
            }

            // Worker commands for escalation steps
            if (approval.EscalationSteps is not null)
            {
                foreach (var step in approval.EscalationSteps)
                {
                    if (emittedWorkerCommands.Add(step.StepName))
                    {
                        sb.AppendLine();
                        EmitExecuteWorkerCommand(sb, model, step.StepName);
                    }
                }
            }

            // Recursively emit commands for nested approvals
            if (approval.NestedEscalationApprovals is not null && approval.NestedEscalationApprovals.Count > 0)
            {
                EmitApprovalCommands(sb, model, approval.NestedEscalationApprovals, emittedWorkerCommands);
            }
        }
    }

    private static void EmitStartCommand(StringBuilder sb, WorkflowModel model)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Start the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Start{model.PascalName}Command(");
        sb.AppendLine("    Guid WorkflowId,");
        sb.AppendLine($"    {stateType} InitialState);");
    }

    private static void EmitStartStepCommand(StringBuilder sb, WorkflowModel model, string stepName)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Start the {stepName} step (internal Saga routing command).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Start{stepName}Command(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId);");
    }

    private static void EmitExecuteCommand(StringBuilder sb, WorkflowModel model, string stepName)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Execute the {stepName} step of the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Execute{stepName}Command(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    Guid StepExecutionId);");
    }

    private static void EmitExecuteWorkerCommand(StringBuilder sb, WorkflowModel model, string stepName)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Execute the {stepName} worker (dispatched to step handler with state).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// Worker commands are routed to dedicated worker handlers, not the saga.");
        sb.AppendLine("/// They do NOT have [SagaIdentity] to avoid incorrect saga routing.");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Execute{stepName}WorkerCommand(");
        sb.AppendLine("    Guid WorkflowId,");
        sb.AppendLine("    Guid StepExecutionId,");
        sb.AppendLine($"    {stateType} State);");
    }

    private static void EmitResumeApprovalCommand(StringBuilder sb, WorkflowModel model, ApprovalModel approval)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Resume the workflow from the {approval.PhaseName} approval checkpoint.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Resume{approval.ApprovalPointName}ApprovalCommand(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    Strategos.Models.ApprovalDecision Decision,");
        sb.AppendLine("    string? SelectedOptionId,");
        sb.AppendLine("    string? Instructions);");
    }

    private static void EmitRequestApprovalEvent(StringBuilder sb, WorkflowModel model, ApprovalModel approval)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Request approval at the {approval.PhaseName} checkpoint.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Request{approval.ApprovalPointName}ApprovalEvent(");
        sb.AppendLine("    Guid WorkflowId,");
        sb.AppendLine("    string ApprovalPointName,");
        sb.AppendLine("    string Context,");
        sb.AppendLine("    TimeSpan Timeout,");
        sb.AppendLine("    IReadOnlyList<Strategos.Models.ApprovalOption>? Options);");
    }

    private static void EmitSetPendingApprovalCommand(StringBuilder sb, WorkflowModel model, ApprovalModel approval)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Set the pending approval request ID for the {approval.PhaseName} checkpoint.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Set{approval.ApprovalPointName}PendingApprovalCommand(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    string ApprovalRequestId);");
    }

    private static void EmitTimeoutCommand(StringBuilder sb, WorkflowModel model, ApprovalModel approval)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Handle timeout for the {approval.PhaseName} approval checkpoint.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record {approval.ApprovalPointName}ApprovalTimeoutCommand(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    string ApprovalRequestId);");
    }

    private static void EmitForkCommands(StringBuilder sb, WorkflowModel model, IReadOnlyList<ForkModel> forks)
    {
        foreach (var fork in forks)
        {
            // Sanitize ForkId for valid C# identifier
            var sanitizedId = fork.ForkId.Replace("-", "_");

            // Dispatch fork command - initiates parallel paths
            sb.AppendLine();
            EmitDispatchForkCommand(sb, model, fork, sanitizedId);

            // Path completed events - one for each parallel path
            foreach (var path in fork.Paths)
            {
                sb.AppendLine();
                EmitPathCompletedEvent(sb, model, fork, path, sanitizedId);
            }

            // Join fork command - triggers join step execution
            sb.AppendLine();
            EmitJoinForkCommand(sb, model, fork, sanitizedId);
        }
    }

    private static void EmitDispatchForkCommand(StringBuilder sb, WorkflowModel model, ForkModel fork, string sanitizedId)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Dispatch parallel paths for fork {fork.ForkId}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record DispatchFork_{sanitizedId}_Command(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId);");
    }

    private static void EmitPathCompletedEvent(StringBuilder sb, WorkflowModel model, ForkModel fork, ForkPathModel path, string sanitizedId)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Path {path.PathIndex} completed for fork {fork.ForkId}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Fork_{sanitizedId}_Path{path.PathIndex}CompletedEvent(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    bool Success,");
        sb.AppendLine($"    {stateType}? PathState,");
        sb.AppendLine("    string? ErrorMessage);");
    }

    private static void EmitJoinForkCommand(StringBuilder sb, WorkflowModel model, ForkModel fork, string sanitizedId)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Join completed paths and execute {fork.JoinStepName} step.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record JoinFork_{sanitizedId}_Command(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId);");
    }

    private static void EmitFailureHandlerCommands(StringBuilder sb, WorkflowModel model, IReadOnlyList<FailureHandlerModel> handlers)
    {
        // Emit the trigger command (one per workflow, triggers first handler's first step)
        sb.AppendLine();
        EmitTriggerFailureHandlerCommand(sb, model);

        // For each failure handler, emit step commands
        foreach (var handler in handlers)
        {
            var sanitizedId = handler.HandlerId.Replace("-", "_");

            foreach (var stepName in handler.StepNames)
            {
                // Start command for internal saga routing
                sb.AppendLine();
                EmitStartFailureHandlerStepCommand(sb, model, handler, stepName, sanitizedId);

                // Worker command with state
                sb.AppendLine();
                EmitExecuteFailureHandlerWorkerCommand(sb, model, handler, stepName, sanitizedId);
            }
        }
    }

    private static void EmitTriggerFailureHandlerCommand(StringBuilder sb, WorkflowModel model)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Trigger the failure handler for the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record Trigger{model.PascalName}FailureHandlerCommand(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    string FailedStepName,");
        sb.AppendLine("    string? ExceptionMessage,");
        sb.AppendLine("    string? ExceptionType,");
        sb.AppendLine("    string? StackTrace);");
    }

    private static void EmitStartFailureHandlerStepCommand(
        StringBuilder sb,
        WorkflowModel model,
        FailureHandlerModel handler,
        string stepName,
        string sanitizedId)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Start the {stepName} failure handler step (internal Saga routing command).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record StartFailureHandler_{sanitizedId}_{stepName}Command(");
        sb.AppendLine("    [property: Wolverine.Persistence.Sagas.SagaIdentity] Guid WorkflowId);");
    }

    private static void EmitExecuteFailureHandlerWorkerCommand(
        StringBuilder sb,
        WorkflowModel model,
        FailureHandlerModel handler,
        string stepName,
        string sanitizedId)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Execute the {stepName} failure handler worker (dispatched to step handler with state).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// Worker commands are routed to dedicated worker handlers, not the saga.");
        sb.AppendLine("/// They do NOT have [SagaIdentity] to avoid incorrect saga routing.");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record ExecuteFailureHandler_{sanitizedId}_{stepName}WorkerCommand(");
        sb.AppendLine("    Guid WorkflowId,");
        sb.AppendLine("    Guid StepExecutionId,");
        sb.AppendLine($"    {stateType} State,");
        sb.AppendLine("    string FailedStepName,");
        sb.AppendLine("    string? ExceptionMessage,");
        sb.AppendLine("    string? ExceptionType,");
        sb.AppendLine("    string? StackTrace);");
    }

    /// <summary>
    /// Extracts the base step name from a phase name that may include loop prefixes.
    /// </summary>
    /// <param name="phaseName">The phase name (e.g., "TargetLoop_VerifyVetoStep").</param>
    /// <returns>The base step name (e.g., "VerifyVetoStep").</returns>
    /// <remarks>
    /// Phase names for loop steps follow the pattern "{LoopName}_{StepName}".
    /// For nested loops, the pattern is "{OuterLoop}_{InnerLoop}_{StepName}".
    /// This method extracts the step name by taking the part after the last underscore.
    /// </remarks>
    private static string ExtractBaseStepName(string phaseName)
    {
        var lastUnderscoreIndex = phaseName.LastIndexOf('_');
        return lastUnderscoreIndex >= 0
            ? phaseName.Substring(lastUnderscoreIndex + 1)
            : phaseName;
    }
}

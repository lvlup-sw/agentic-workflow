// -----------------------------------------------------------------------
// <copyright file="StateReducerEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Text;

using Strategos.Generators.Helpers;
using Strategos.Generators.Models;
using Strategos.Generators.Polyfills;

namespace Strategos.Generators.Emitters;

/// <summary>
/// Emits the state reducer source code for workflow state types.
/// </summary>
/// <remarks>
/// Generates a static reducer class that merges state updates using
/// property-specific semantics (overwrite, append, merge).
/// </remarks>
internal static class StateReducerEmitter
{
    /// <summary>
    /// Generates the state reducer source code for the given state model.
    /// </summary>
    /// <param name="model">The state model containing type and property information.</param>
    /// <returns>The generated C# source code for the state reducer.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(StateModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);
        FileHeaderHelper.AppendUsings(
            sb,
            "System.CodeDom.Compiler",
            "System.Collections.Generic",
            "System.Collections.Immutable",
            "System.Linq");

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Class declaration with attributes
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// State reducer for <see cref=\"{model.TypeName}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Strategos.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public static partial class {model.ReducerClassName}");
        sb.AppendLine("{");

        // Reduce method
        EmitReduceMethod(sb, model);

        // Generate helper methods if needed
        if (model.Properties.Any(p => p.Kind == StatePropertyKind.Merge))
        {
            sb.AppendLine();
            EmitMergeDictionariesHelper(sb);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitReduceMethod(StringBuilder sb, StateModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Reduces the current state with an update to produce a new state.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"current\">The current state.</param>");
        sb.AppendLine("    /// <param name=\"update\">The state update to apply.</param>");
        sb.AppendLine("    /// <returns>A new state with the update applied.</returns>");
        sb.AppendLine($"    public static {model.TypeName} Reduce({model.TypeName} current, {model.TypeName} update)");
        sb.AppendLine("    {");

        if (model.Properties.Count == 0)
        {
            sb.AppendLine($"        return current with {{ }};");
        }
        else
        {
            sb.AppendLine("        return current with");
            sb.AppendLine("        {");

            for (var i = 0; i < model.Properties.Count; i++)
            {
                var property = model.Properties[i];
                var assignment = GetPropertyAssignment(property);
                var separator = i < model.Properties.Count - 1 ? "," : string.Empty;
                sb.AppendLine($"            {property.Name} = {assignment}{separator}");
            }

            sb.AppendLine("        };");
        }

        sb.AppendLine("    }");
    }

    private static string GetPropertyAssignment(StatePropertyModel property)
    {
        return property.Kind switch
        {
            StatePropertyKind.Standard => $"update.{property.Name}",
            StatePropertyKind.Append => $"current.{property.Name}.Concat(update.{property.Name}).ToList()",
            StatePropertyKind.Merge => $"MergeDictionaries(current.{property.Name}, update.{property.Name})",
            _ => $"update.{property.Name}",
        };
    }

    private static void EmitMergeDictionariesHelper(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Merges two dictionaries with last-write-wins semantics.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <typeparam name=\"TKey\">The key type.</typeparam>");
        sb.AppendLine("    /// <typeparam name=\"TValue\">The value type.</typeparam>");
        sb.AppendLine("    /// <param name=\"current\">The current dictionary.</param>");
        sb.AppendLine("    /// <param name=\"update\">The dictionary with updates.</param>");
        sb.AppendLine("    /// <returns>A new immutable dictionary with merged values.</returns>");
        sb.AppendLine("    private static ImmutableDictionary<TKey, TValue> MergeDictionaries<TKey, TValue>(");
        sb.AppendLine("        IReadOnlyDictionary<TKey, TValue> current,");
        sb.AppendLine("        IReadOnlyDictionary<TKey, TValue> update)");
        sb.AppendLine("        where TKey : notnull");
        sb.AppendLine("    {");
        sb.AppendLine("        var builder = ImmutableDictionary.CreateBuilder<TKey, TValue>();");
        sb.AppendLine("        foreach (var kvp in current)");
        sb.AppendLine("        {");
        sb.AppendLine("            builder[kvp.Key] = kvp.Value;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        foreach (var kvp in update)");
        sb.AppendLine("        {");
        sb.AppendLine("            builder[kvp.Key] = kvp.Value;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return builder.ToImmutable();");
        sb.AppendLine("    }");
    }
}

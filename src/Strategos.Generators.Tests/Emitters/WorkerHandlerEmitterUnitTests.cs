// -----------------------------------------------------------------------
// <copyright file="WorkerHandlerEmitterUnitTests.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using Strategos.Generators.Emitters;
using Strategos.Generators.Models;

namespace Strategos.Generators.Tests.Emitters;

/// <summary>
/// Unit tests for the <see cref="WorkerHandlerEmitter"/> class.
/// </summary>
/// <remarks>
/// These tests verify worker handler generation following the Brain &amp; Muscle pattern.
/// Workers execute steps (Muscle) while Sagas manage state transitions (Brain).
/// </remarks>
[Property("Category", "Unit")]
public class WorkerHandlerEmitterUnitTests
{
    // =============================================================================
    // A. File Structure Tests
    // =============================================================================

    /// <summary>
    /// Verifies that the emitter generates auto-generated header.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesAutoGeneratedHeader()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("// <auto-generated/>");
    }

    /// <summary>
    /// Verifies that the emitter includes nullable enable directive.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesNullableEnable()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("#nullable enable");
    }

    /// <summary>
    /// Verifies that the emitter uses the correct namespace.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_UsesCorrectNamespace()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("namespace TestNamespace;");
    }

    /// <summary>
    /// Verifies that the emitter includes GeneratedCode attribute.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesGeneratedCodeAttribute()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("[GeneratedCode(\"Strategos.Generators\"");
    }

    // =============================================================================
    // B. Handler Class Generation Tests
    // =============================================================================

    /// <summary>
    /// Verifies that a handler class is generated for each step.
    /// </summary>
    [Test]
    public async Task Emit_LinearWorkflow_GeneratesHandlerPerStep()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - handlers are now sealed partial classes
        await Assert.That(source).Contains("public sealed partial class ValidateOrderHandler");
        await Assert.That(source).Contains("public sealed partial class ProcessPaymentHandler");
        await Assert.That(source).Contains("public sealed partial class SendConfirmationHandler");
    }

    /// <summary>
    /// Verifies that handlers inject the step type and ILogger via constructor.
    /// </summary>
    [Test]
    public async Task Emit_Handler_InjectsStepAndLoggerViaConstructor()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - Primary constructor with step and ILogger parameters
        await Assert.That(source).Contains("ValidateOrderHandler(");
        await Assert.That(source).Contains("ValidateOrder step,");
        await Assert.That(source).Contains("ILogger<ValidateOrderHandler> logger)");
    }

    /// <summary>
    /// Verifies that handlers have XML documentation.
    /// </summary>
    [Test]
    public async Task Emit_Handler_IncludesXmlDocumentation()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("/// <summary>");
        await Assert.That(source).Contains("/// Worker handler for the ValidateOrder step");
    }

    // =============================================================================
    // C. Handle Method Tests
    // =============================================================================

    /// <summary>
    /// Verifies that handlers have a Handle method for the worker command.
    /// </summary>
    [Test]
    public async Task Emit_Handler_HasHandleMethodForWorkerCommand()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - Handle method accepts the worker command (line break in signature)
        await Assert.That(source).Contains("ExecuteValidateOrderWorkerCommand command");
    }

    /// <summary>
    /// Verifies that Handle method is async.
    /// </summary>
    [Test]
    public async Task Emit_Handler_HandleMethodIsAsync()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("public async Task<ValidateOrderCompleted> Handle(");
    }

    /// <summary>
    /// Verifies that Handle method returns the completion event.
    /// </summary>
    [Test]
    public async Task Emit_Handler_HandleMethodReturnsCompletedEvent()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("return new ValidateOrderCompleted(");
    }

    /// <summary>
    /// Verifies that Handle method supports CancellationToken.
    /// </summary>
    [Test]
    public async Task Emit_Handler_HandleMethodAcceptsCancellationToken()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("CancellationToken ct");
    }

    // =============================================================================
    // D. Step Execution Tests
    // =============================================================================

    /// <summary>
    /// Verifies that Handle method creates a StepContext.
    /// </summary>
    [Test]
    public async Task Emit_Handler_CreatesStepContext()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - variable name is stepContext
        await Assert.That(source).Contains("var stepContext = StepContext.Create(");
    }

    /// <summary>
    /// Verifies that Handle method calls ExecuteAsync on the step.
    /// </summary>
    [Test]
    public async Task Emit_Handler_CallsStepExecuteAsync()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("_step.ExecuteAsync(");
    }

    /// <summary>
    /// Verifies that Handle method passes state from command to step.
    /// </summary>
    [Test]
    public async Task Emit_Handler_PassesStateToStep()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("command.State");
    }

    /// <summary>
    /// Verifies that completion event includes workflow ID.
    /// </summary>
    [Test]
    public async Task Emit_Handler_CompletionEventIncludesWorkflowId()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("command.WorkflowId");
    }

    /// <summary>
    /// Verifies that completion event includes updated state.
    /// </summary>
    [Test]
    public async Task Emit_Handler_CompletionEventIncludesUpdatedState()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("result.UpdatedState");
    }

    // =============================================================================
    // E. Guard Clause Tests
    // =============================================================================

    /// <summary>
    /// Verifies that null model throws ArgumentNullException.
    /// </summary>
    [Test]
    public async Task Emit_WithNullModel_ThrowsArgumentNullException()
    {
        // Arrange & Act & Assert
        await Assert.That(() => WorkerHandlerEmitter.Emit(null!))
            .Throws<ArgumentNullException>();
    }

    /// <summary>
    /// Verifies that Handle method validates command argument.
    /// </summary>
    [Test]
    public async Task Emit_Handler_ValidatesCommandArgument()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("ArgumentNullException.ThrowIfNull(command");
    }

    // =============================================================================
    // F. Step Type Reference Tests
    // =============================================================================

    /// <summary>
    /// Verifies that handlers reference step interface correctly.
    /// </summary>
    [Test]
    public async Task Emit_Handler_ReferencesStepInterface()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - Handler should use concrete step type injected by DI
        await Assert.That(source).Contains("private readonly ValidateOrder _step");
    }

    // =============================================================================
    // G. Instance Name Tests (Phase 2 - Handler Deduplication)
    // =============================================================================

    /// <summary>
    /// Verifies that only ONE handler is generated per step TYPE, even when same type
    /// is used with different instance names. Handlers are shared (deduped by StepName).
    /// </summary>
    /// <remarks>
    /// This test ensures that Wolverine's message-type-based routing works correctly.
    /// All instances of AnalyzeStep share the same handler class.
    /// </remarks>
    [Test]
    public async Task Emit_WithInstanceNames_GeneratesOneHandlerPerType()
    {
        // Arrange - Same step type (AnalyzeStep) with different instance names
        var steps = new List<StepModel>
        {
            StepModel.Create("PrepareData", "TestNamespace.PrepareData"),
            StepModel.Create("AnalyzeStep", "TestNamespace.AnalyzeStep", instanceName: "Technical"),
            StepModel.Create("AnalyzeStep", "TestNamespace.AnalyzeStep", instanceName: "Fundamental"),
            StepModel.Create("SynthesizeResults", "TestNamespace.SynthesizeResults"),
        };

        var model = new WorkflowModel(
            WorkflowName: "multi-analysis",
            PascalName: "MultiAnalysis",
            Namespace: "TestNamespace",
            StepNames: ["PrepareData", "Technical", "Fundamental", "SynthesizeResults"],
            StateTypeName: "AnalysisState",
            Steps: steps);

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - Should have ONE AnalyzeStepHandler, not TechnicalHandler/FundamentalHandler
        await Assert.That(source).Contains("AnalyzeStepHandler");
        await Assert.That(source).DoesNotContain("TechnicalHandler");
        await Assert.That(source).DoesNotContain("FundamentalHandler");

        // Count occurrences of AnalyzeStepHandler - should appear only once as class definition
        // (may appear multiple times in comments/references, but class def should be once)
        var classDefinitionCount = CountOccurrences(source, "public sealed partial class AnalyzeStepHandler");
        await Assert.That(classDefinitionCount).IsEqualTo(1);
    }

    /// <summary>
    /// Verifies that handlers use step TYPE name for command/event types.
    /// </summary>
    [Test]
    public async Task Emit_WithInstanceNames_UsesStepTypeForCommandsAndEvents()
    {
        // Arrange
        var steps = new List<StepModel>
        {
            StepModel.Create("AnalyzeStep", "TestNamespace.AnalyzeStep", instanceName: "Technical"),
            StepModel.Create("AnalyzeStep", "TestNamespace.AnalyzeStep", instanceName: "Fundamental"),
        };

        var model = new WorkflowModel(
            WorkflowName: "multi-analysis",
            PascalName: "MultiAnalysis",
            Namespace: "TestNamespace",
            StepNames: ["Technical", "Fundamental"],
            StateTypeName: "AnalysisState",
            Steps: steps);

        // Act
        var source = WorkerHandlerEmitter.Emit(model);

        // Assert - Commands and events use step TYPE name
        await Assert.That(source).Contains("ExecuteAnalyzeStepWorkerCommand");
        await Assert.That(source).Contains("AnalyzeStepCompleted");

        // Should NOT have instance-name-based commands/events
        await Assert.That(source).DoesNotContain("ExecuteTechnicalWorkerCommand");
        await Assert.That(source).DoesNotContain("TechnicalCompleted");
    }

    // =============================================================================
    // Helper Methods
    // =============================================================================

    private static WorkflowModel CreateTestModel()
    {
        return new WorkflowModel(
            WorkflowName: "process-order",
            PascalName: "ProcessOrder",
            Namespace: "TestNamespace",
            StepNames: ["ValidateOrder", "ProcessPayment", "SendConfirmation"],
            StateTypeName: "OrderState");
    }

    private static int CountOccurrences(string source, string pattern)
    {
        var count = 0;
        var index = 0;
        while ((index = source.IndexOf(pattern, index, StringComparison.Ordinal)) != -1)
        {
            count++;
            index += pattern.Length;
        }

        return count;
    }
}

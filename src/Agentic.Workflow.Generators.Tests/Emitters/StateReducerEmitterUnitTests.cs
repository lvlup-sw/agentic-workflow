// -----------------------------------------------------------------------
// <copyright file="StateReducerEmitterUnitTests.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

namespace Agentic.Workflow.Generators.Tests.Emitters;

using Agentic.Workflow.Generators.Emitters;
using Agentic.Workflow.Generators.Models;

/// <summary>
/// Unit tests for the <see cref="StateReducerEmitter"/> class.
/// </summary>
/// <remarks>
/// These tests verify the emitter in isolation, independent of the source generator.
/// </remarks>
[Property("Category", "Unit")]
public class StateReducerEmitterUnitTests
{
    // =============================================================================
    // A. Guard Clause Tests
    // =============================================================================

    /// <summary>
    /// Verifies that null model throws ArgumentNullException.
    /// </summary>
    [Test]
    public async Task Emit_WithNullModel_ThrowsArgumentNullException()
    {
        // Arrange & Act & Assert
        await Assert.That(() => StateReducerEmitter.Emit(null!))
            .Throws<ArgumentNullException>();
    }

    // =============================================================================
    // B. Basic Structure Tests
    // =============================================================================

    /// <summary>
    /// Verifies that the emitter returns valid, non-empty source code.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_ReturnsNonEmptySource()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).IsNotNull();
        await Assert.That(source.Length).IsGreaterThan(0);
    }

    /// <summary>
    /// Verifies that the auto-generated header is included.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesAutoGeneratedHeader()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("// <auto-generated/>");
    }

    /// <summary>
    /// Verifies that nullable enable directive is included.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesNullableEnable()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("#nullable enable");
    }

    /// <summary>
    /// Verifies that the emitter uses the correct namespace.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_UsesCorrectNamespace()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("namespace TestNamespace;");
    }

    /// <summary>
    /// Verifies that the emitter generates a static reducer class.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_GeneratesStaticReducerClass()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("public static partial class OrderStateReducer");
    }

    /// <summary>
    /// Verifies that GeneratedCode attribute is included.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_IncludesGeneratedCodeAttribute()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("[GeneratedCode(\"Agentic.Workflow.Generators\"");
    }

    // =============================================================================
    // C. Reduce Method Tests
    // =============================================================================

    /// <summary>
    /// Verifies that the emitter generates a Reduce method.
    /// </summary>
    [Test]
    public async Task Emit_WithValidModel_GeneratesReduceMethod()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("public static OrderState Reduce(");
    }

    /// <summary>
    /// Verifies that the Reduce method has current and update parameters.
    /// </summary>
    [Test]
    public async Task Emit_ReduceMethod_HasCurrentAndUpdateParameters()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("OrderState current");
        await Assert.That(source).Contains("OrderState update");
    }

    /// <summary>
    /// Verifies that the Reduce method returns the state type.
    /// </summary>
    [Test]
    public async Task Emit_ReduceMethod_ReturnsStateType()
    {
        // Arrange
        var model = CreateTestModel();

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("return current with");
    }

    // =============================================================================
    // D. Standard Property Tests
    // =============================================================================

    /// <summary>
    /// Verifies that standard properties generate overwrite assignment.
    /// </summary>
    [Test]
    public async Task Emit_WithStandardProperty_GeneratesOverwriteAssignment()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties: [new StatePropertyModel("Status", "string", StatePropertyKind.Standard)]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("Status = update.Status");
    }

    /// <summary>
    /// Verifies that multiple standard properties generate all assignments.
    /// </summary>
    [Test]
    public async Task Emit_WithMultipleStandardProperties_GeneratesAllAssignments()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties:
            [
                new StatePropertyModel("Status", "string", StatePropertyKind.Standard),
                new StatePropertyModel("Total", "decimal", StatePropertyKind.Standard),
            ]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("Status = update.Status");
        await Assert.That(source).Contains("Total = update.Total");
    }

    // =============================================================================
    // E. Append Property Tests
    // =============================================================================

    /// <summary>
    /// Verifies that append properties generate concat expression.
    /// </summary>
    [Test]
    public async Task Emit_WithAppendProperty_GeneratesConcatExpression()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties: [new StatePropertyModel("Items", "IReadOnlyList<string>", StatePropertyKind.Append)]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("current.Items.Concat(update.Items)");
    }

    /// <summary>
    /// Verifies that append properties generate ToList call.
    /// </summary>
    [Test]
    public async Task Emit_WithAppendProperty_CallsToList()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties: [new StatePropertyModel("Items", "IReadOnlyList<string>", StatePropertyKind.Append)]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains(".ToList()");
    }

    /// <summary>
    /// Verifies that multiple append properties are handled.
    /// </summary>
    [Test]
    public async Task Emit_MultipleAppendProperties_HandlesAll()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties:
            [
                new StatePropertyModel("Items", "IReadOnlyList<string>", StatePropertyKind.Append),
                new StatePropertyModel("Tasks", "IReadOnlyList<TaskEntry>", StatePropertyKind.Append),
            ]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("current.Items.Concat(update.Items)");
        await Assert.That(source).Contains("current.Tasks.Concat(update.Tasks)");
    }

    // =============================================================================
    // F. Merge Property Tests
    // =============================================================================

    /// <summary>
    /// Verifies that merge properties generate merge expression.
    /// </summary>
    [Test]
    public async Task Emit_WithMergeProperty_GeneratesMergeExpression()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties: [new StatePropertyModel("Metadata", "IReadOnlyDictionary<string, string>", StatePropertyKind.Merge)]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("MergeDictionaries(current.Metadata, update.Metadata)");
    }

    /// <summary>
    /// Verifies that merge uses last-write-wins semantics.
    /// </summary>
    [Test]
    public async Task Emit_WithMergeProperty_LastWriteWins()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties: [new StatePropertyModel("Metadata", "IReadOnlyDictionary<string, string>", StatePropertyKind.Merge)]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert - MergeDictionaries helper should be generated (returns ImmutableDictionary for proper immutability)
        await Assert.That(source).Contains("private static ImmutableDictionary<TKey, TValue> MergeDictionaries<TKey, TValue>");
    }

    /// <summary>
    /// Verifies that multiple merge properties are handled.
    /// </summary>
    [Test]
    public async Task Emit_MultipleMergeProperties_HandlesAll()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties:
            [
                new StatePropertyModel("Metadata", "IReadOnlyDictionary<string, string>", StatePropertyKind.Merge),
                new StatePropertyModel("Tags", "IReadOnlyDictionary<string, object>", StatePropertyKind.Merge),
            ]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("MergeDictionaries(current.Metadata, update.Metadata)");
        await Assert.That(source).Contains("MergeDictionaries(current.Tags, update.Tags)");
    }

    // =============================================================================
    // G. Edge Case Tests
    // =============================================================================

    /// <summary>
    /// Verifies that empty properties list generates valid reducer.
    /// </summary>
    [Test]
    public async Task Emit_StateWithNoProperties_GeneratesEmptyReducer()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "EmptyState",
            Namespace: "TestNamespace",
            Properties: []);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("public static partial class EmptyStateReducer");
        await Assert.That(source).Contains("return current with");
    }

    /// <summary>
    /// Verifies that mixed property kinds generate correct reducer.
    /// </summary>
    [Test]
    public async Task Emit_MixedPropertyKinds_GeneratesCorrectReducer()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties:
            [
                new StatePropertyModel("Status", "string", StatePropertyKind.Standard),
                new StatePropertyModel("Items", "IReadOnlyList<string>", StatePropertyKind.Append),
                new StatePropertyModel("Tags", "IReadOnlyDictionary<string, string>", StatePropertyKind.Merge),
            ]);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("Status = update.Status");
        await Assert.That(source).Contains("current.Items.Concat(update.Items)");
        await Assert.That(source).Contains("MergeDictionaries(current.Tags, update.Tags)");
    }

    /// <summary>
    /// Verifies that nested namespaces are handled correctly.
    /// </summary>
    [Test]
    public async Task Emit_NestedNamespace_HandlesCorrectly()
    {
        // Arrange
        var model = new StateModel(
            TypeName: "OrderState",
            Namespace: "Company.Product.Domain",
            Properties: []);

        // Act
        var source = StateReducerEmitter.Emit(model);

        // Assert
        await Assert.That(source).Contains("namespace Company.Product.Domain;");
    }

    // =============================================================================
    // Helper Methods
    // =============================================================================

    private static StateModel CreateTestModel()
    {
        return new StateModel(
            TypeName: "OrderState",
            Namespace: "TestNamespace",
            Properties:
            [
                new StatePropertyModel("Status", "string", StatePropertyKind.Standard),
                new StatePropertyModel("Items", "IReadOnlyList<OrderItem>", StatePropertyKind.Append),
                new StatePropertyModel("Metadata", "IReadOnlyDictionary<string, string>", StatePropertyKind.Merge),
            ]);
    }
}

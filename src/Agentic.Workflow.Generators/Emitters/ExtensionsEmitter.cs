// -----------------------------------------------------------------------
// <copyright file="ExtensionsEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Linq;
using System.Text;

using Agentic.Workflow.Generators.Helpers;
using Agentic.Workflow.Generators.Models;
using Agentic.Workflow.Generators.Polyfills;

namespace Agentic.Workflow.Generators.Emitters;

/// <summary>
/// Emits DI extension methods for workflow registration.
/// </summary>
internal static class ExtensionsEmitter
{
    /// <summary>
    /// Generates the DI extension method source code for the given workflow model.
    /// </summary>
    /// <param name="model">The workflow model containing registration information.</param>
    /// <returns>The generated C# source code for the extension method.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);

        // Collect usings including step namespaces
        var usings = new List<string>
        {
            "System",
            "System.CodeDom.Compiler",
            "Microsoft.Extensions.DependencyInjection",
        };

        // Add step type namespaces from the model
        if (model.Steps is not null)
        {
            foreach (var step in model.Steps)
            {
                var ns = GetNamespaceFromTypeName(step.StepTypeName);
                if (!string.IsNullOrEmpty(ns) && !usings.Contains(ns))
                {
                    usings.Add(ns);
                }
            }
        }

        FileHeaderHelper.AppendUsings(sb, usings.ToArray());

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Extension class
        EmitExtensionsClass(sb, model);

        return sb.ToString();
    }

    /// <summary>
    /// Extracts the namespace from a fully qualified type name.
    /// </summary>
    private static string GetNamespaceFromTypeName(string typeName)
    {
        var lastDot = typeName.LastIndexOf('.');
        return lastDot > 0 ? typeName.Substring(0, lastDot) : string.Empty;
    }

    /// <summary>
    /// Gets the unique step names from the model, using Steps collection if available, otherwise StepNames.
    /// </summary>
    private static IEnumerable<string> GetStepNames(WorkflowModel model)
    {
        if (model.Steps is not null)
        {
            return model.Steps.Select(s => s.StepName);
        }

        return model.StepNames;
    }

    private static void EmitExtensionsClass(StringBuilder sb, WorkflowModel model)
    {
        // XML documentation
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// DI extension methods for the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public static partial class {model.PascalName}WorkflowExtensions");
        sb.AppendLine("{");

        // Add method
        EmitAddMethod(sb, model);

        sb.AppendLine("}");
    }

    private static void EmitAddMethod(StringBuilder sb, WorkflowModel model)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Registers the {model.WorkflowName} workflow with the service collection.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"services\">The service collection to register with.</param>");
        sb.AppendLine("    /// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"    public static IServiceCollection Add{model.PascalName}Workflow(");
        sb.AppendLine("        this IServiceCollection services)");
        sb.AppendLine("    {");
        sb.AppendLine("        ArgumentNullException.ThrowIfNull(services, nameof(services));");
        sb.AppendLine();

        // Register unique step types (not phase names which may include loop prefixes)
        sb.AppendLine("        // Register step types");
        var registeredStepTypes = new HashSet<string>(StringComparer.Ordinal);
        var stepNames = GetStepNames(model);
        foreach (var stepName in stepNames)
        {
            if (registeredStepTypes.Add(stepName))
            {
                sb.AppendLine($"        services.AddTransient<{stepName}>();");
            }
        }

        // Register branch case step types
        if (model.Branches is not null)
        {
            foreach (var branch in model.Branches)
            {
                foreach (var branchCase in branch.Cases)
                {
                    foreach (var stepName in branchCase.StepNames)
                    {
                        if (registeredStepTypes.Add(stepName))
                        {
                            sb.AppendLine($"        services.AddTransient<{stepName}>();");
                        }
                    }
                }
            }
        }

        sb.AppendLine();

        // Register worker handlers (one per unique step type)
        sb.AppendLine("        // Register worker handlers");
        registeredStepTypes.Clear();
        foreach (var stepName in stepNames)
        {
            if (registeredStepTypes.Add(stepName))
            {
                sb.AppendLine($"        services.AddTransient<{stepName}Handler>();");
            }
        }

        // Register branch case step handlers
        if (model.Branches is not null)
        {
            foreach (var branch in model.Branches)
            {
                foreach (var branchCase in branch.Cases)
                {
                    foreach (var stepName in branchCase.StepNames)
                    {
                        if (registeredStepTypes.Add(stepName))
                        {
                            sb.AppendLine($"        services.AddTransient<{stepName}Handler>();");
                        }
                    }
                }
            }
        }

        sb.AppendLine();

        // Force evaluation of workflow definition to register loop conditions
        // The Definition property triggers the fluent DSL builder chain which
        // registers conditions in WorkflowConditionRegistry for runtime lookup
        sb.AppendLine("        // Force evaluation of workflow definition to register loop conditions");
        sb.AppendLine($"        _ = {model.PascalName}WorkflowDefinition.Definition;");

        sb.AppendLine();
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
    }
}

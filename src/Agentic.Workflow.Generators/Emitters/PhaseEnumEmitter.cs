// -----------------------------------------------------------------------
// <copyright file="PhaseEnumEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Text;

using Agentic.Workflow.Generators.Helpers;
using Agentic.Workflow.Generators.Models;
using Agentic.Workflow.Generators.Polyfills;

namespace Agentic.Workflow.Generators.Emitters;

/// <summary>
/// Emits the Phase enum source code for a workflow.
/// </summary>
internal static class PhaseEnumEmitter
{
    /// <summary>
    /// Generates the phase enumeration source code for the given workflow model.
    /// </summary>
    /// <param name="model">The workflow model containing phase information.</param>
    /// <returns>The generated C# source code for the phase enum.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);
        FileHeaderHelper.AppendUsings(sb, "System.CodeDom.Compiler", "System.Text.Json.Serialization");

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Enum declaration with attributes
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Phase enumeration for the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine("[JsonConverter(typeof(JsonStringEnumConverter))]");
        sb.AppendLine($"public enum {model.PhaseEnumName}");
        sb.AppendLine("{");

        // Standard phase: NotStarted
        sb.AppendLine("    /// <summary>Workflow has not yet started.</summary>");
        sb.AppendLine("    NotStarted,");
        sb.AppendLine();

        // Track emitted step names to avoid duplicates with branch phases
        var emittedSteps = new HashSet<string>(model.StepNames);

        // Step phases
        foreach (var stepName in model.StepNames)
        {
            sb.AppendLine($"    /// <summary>Executing {stepName} step.</summary>");
            sb.AppendLine($"    {stepName},");
            sb.AppendLine();
        }

        // Approval checkpoint phases (including escalation/rejection step phases)
        if (model.HasApprovalPoints)
        {
            EmitApprovalPhases(sb, model.ApprovalPoints!, emittedSteps);
        }

        // Fork lifecycle phases (Forking_ and Joining_ for each fork)
        if (model.HasForks)
        {
            EmitForkPhases(sb, model.Forks!);
        }

        // Branch case step phases
        if (model.HasBranches)
        {
            EmitBranchPhases(sb, model.Branches!, emittedSteps);
        }

        // Failure handler phases (FailureHandler_{Id}_{Step} for each step in handler)
        if (model.HasFailureHandlers)
        {
            EmitFailureHandlerPhases(sb, model.FailureHandlers!);
        }

        // Standard terminal phases
        sb.AppendLine("    /// <summary>Workflow completed successfully.</summary>");
        sb.AppendLine("    Completed,");
        sb.AppendLine();
        sb.AppendLine("    /// <summary>Workflow failed.</summary>");
        sb.AppendLine("    Failed,");

        // Conditional ValidationFailed phase (only when workflow has validation guards)
        if (model.HasAnyValidation)
        {
            sb.AppendLine();
            sb.AppendLine("    /// <summary>Validation guard failed.</summary>");
            sb.AppendLine("    ValidationFailed,");
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void EmitApprovalPhases(StringBuilder sb, IReadOnlyList<ApprovalModel> approvals, HashSet<string> emittedSteps)
    {
        foreach (var approval in approvals)
        {
            // Main approval phase
            sb.AppendLine($"    /// <summary>Awaiting approval from {approval.ApproverTypeName}.</summary>");
            sb.AppendLine($"    {approval.PhaseName},");
            sb.AppendLine();

            // Rejection step phases (skip if already emitted in main step list)
            if (approval.RejectionSteps is not null && approval.RejectionSteps.Count > 0)
            {
                foreach (var step in approval.RejectionSteps)
                {
                    if (emittedSteps.Contains(step.StepName))
                    {
                        continue;
                    }

                    sb.AppendLine($"    /// <summary>Executing rejection step {step.StepName}.</summary>");
                    sb.AppendLine($"    {step.StepName},");
                    sb.AppendLine();
                }
            }

            // Escalation step phases (skip if already emitted in main step list)
            if (approval.EscalationSteps is not null && approval.EscalationSteps.Count > 0)
            {
                foreach (var step in approval.EscalationSteps)
                {
                    if (emittedSteps.Contains(step.StepName))
                    {
                        continue;
                    }

                    sb.AppendLine($"    /// <summary>Executing escalation step {step.StepName}.</summary>");
                    sb.AppendLine($"    {step.StepName},");
                    sb.AppendLine();
                }
            }

            // Nested approval phases (recursive)
            if (approval.NestedEscalationApprovals is not null && approval.NestedEscalationApprovals.Count > 0)
            {
                EmitApprovalPhases(sb, approval.NestedEscalationApprovals, emittedSteps);
            }
        }
    }

    private static void EmitForkPhases(StringBuilder sb, IReadOnlyList<ForkModel> forks)
    {
        foreach (var fork in forks)
        {
            // Sanitize ForkId for valid C# identifier (replace hyphens with underscores)
            var sanitizedId = fork.ForkId.Replace("-", "_");

            // Forking phase - when fork is dispatching parallel paths
            sb.AppendLine($"    /// <summary>Dispatching parallel paths for fork {fork.ForkId}.</summary>");
            sb.AppendLine($"    Forking_{sanitizedId},");
            sb.AppendLine();

            // Joining phase - when all paths complete and awaiting join step
            sb.AppendLine($"    /// <summary>Awaiting join for fork {fork.ForkId}.</summary>");
            sb.AppendLine($"    Joining_{sanitizedId},");
            sb.AppendLine();
        }
    }

    private static void EmitFailureHandlerPhases(StringBuilder sb, IReadOnlyList<FailureHandlerModel> handlers)
    {
        foreach (var handler in handlers)
        {
            // Sanitize HandlerId for valid C# identifier (replace hyphens with underscores)
            var sanitizedId = handler.HandlerId.Replace("-", "_");

            foreach (var stepName in handler.StepNames)
            {
                sb.AppendLine($"    /// <summary>Executing failure handler step {stepName}.</summary>");
                sb.AppendLine($"    FailureHandler_{sanitizedId}_{stepName},");
                sb.AppendLine();
            }
        }
    }

    private static void EmitBranchPhases(
        StringBuilder sb,
        IReadOnlyList<BranchModel> branches,
        HashSet<string> emittedSteps)
    {
        foreach (var branch in branches)
        {
            foreach (var branchCase in branch.Cases)
            {
                foreach (var stepName in branchCase.StepNames)
                {
                    // Skip if already emitted in main step list
                    if (emittedSteps.Contains(stepName))
                    {
                        continue;
                    }

                    sb.AppendLine($"    /// <summary>Executing branch step {stepName}.</summary>");
                    sb.AppendLine($"    {stepName},");
                    sb.AppendLine();
                }
            }
        }
    }
}

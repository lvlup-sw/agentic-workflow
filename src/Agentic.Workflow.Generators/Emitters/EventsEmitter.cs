// -----------------------------------------------------------------------
// <copyright file="EventsEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Text;
using Agentic.Workflow.Generators.Helpers;
using Agentic.Workflow.Generators.Models;
using Agentic.Workflow.Generators.Polyfills;

namespace Agentic.Workflow.Generators.Emitters;

/// <summary>
/// Emits Marten event records for a workflow.
/// </summary>
internal static class EventsEmitter
{
    /// <summary>
    /// Generates the event records source code for the given workflow model.
    /// </summary>
    /// <param name="model">The workflow model containing event information.</param>
    /// <returns>The generated C# source code for the event records.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);
        FileHeaderHelper.AppendUsings(
            sb,
            "System",
            "System.CodeDom.Compiler",
            "Agentic.AgentHost.Events",
            "Wolverine.Marten",
            "Wolverine.Persistence.Sagas");

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Event interface
        EmitEventInterface(sb, model);
        sb.AppendLine();

        // Workflow Started event
        EmitStartedEvent(sb, model);

        // Step Completed events for each unique STEP TYPE (deduplicated)
        // Workers return events using unprefixed step type names
        var emittedStepEvents = new HashSet<string>(StringComparer.Ordinal);
        if (model.Steps is not null)
        {
            foreach (var step in model.Steps)
            {
                if (emittedStepEvents.Add(step.StepName))
                {
                    sb.AppendLine();
                    EmitStepCompletedEvent(sb, model, step.StepName);
                }
            }
        }
        else
        {
            // Fallback for models without Step collection - use phase names
            foreach (var stepName in model.StepNames)
            {
                sb.AppendLine();
                EmitStepCompletedEvent(sb, model, stepName);
            }
        }

        // Fork path step completed events and join step events
        if (model.Forks is not null)
        {
            foreach (var fork in model.Forks)
            {
                // Generate events for fork path steps
                foreach (var path in fork.Paths)
                {
                    foreach (var stepName in path.StepNames)
                    {
                        if (emittedStepEvents.Add(stepName))
                        {
                            sb.AppendLine();
                            EmitStepCompletedEvent(sb, model, stepName);
                        }
                    }
                }

                // Generate event for fork join step
                if (!string.IsNullOrEmpty(fork.JoinStepName) && emittedStepEvents.Add(fork.JoinStepName))
                {
                    sb.AppendLine();
                    EmitStepCompletedEvent(sb, model, fork.JoinStepName);
                }
            }
        }

        // Branch case step completed events
        // These steps execute conditionally based on discriminator
        if (model.Branches is not null)
        {
            foreach (var branch in model.Branches)
            {
                foreach (var branchCase in branch.Cases)
                {
                    foreach (var stepName in branchCase.StepNames)
                    {
                        if (emittedStepEvents.Add(stepName))
                        {
                            sb.AppendLine();
                            EmitStepCompletedEvent(sb, model, stepName);
                        }
                    }
                }
            }
        }

        // Loop exit branch step completed events
        if (model.Loops is not null)
        {
            foreach (var loop in model.Loops)
            {
                if (loop.BranchOnExit is not null)
                {
                    foreach (var branchCase in loop.BranchOnExit.Cases)
                    {
                        foreach (var stepName in branchCase.StepNames)
                        {
                            if (emittedStepEvents.Add(stepName))
                            {
                                sb.AppendLine();
                                EmitStepCompletedEvent(sb, model, stepName);
                            }
                        }
                    }
                }
            }
        }

        // Failure handler step completed events (simple naming)
        // These use the simple naming pattern to support unified step handling
        if (model.FailureHandlers is not null)
        {
            foreach (var handler in model.FailureHandlers)
            {
                foreach (var stepName in handler.StepNames)
                {
                    if (emittedStepEvents.Add(stepName))
                    {
                        sb.AppendLine();
                        EmitStepCompletedEvent(sb, model, stepName);
                    }
                }
            }
        }

        // Approval rejection/escalation step completed events
        if (model.ApprovalPoints is not null)
        {
            EmitApprovalStepEvents(sb, model, model.ApprovalPoints, emittedStepEvents);
        }

        // ValidationFailed event (only when workflow has validation guards)
        if (model.HasAnyValidation)
        {
            sb.AppendLine();
            EmitValidationFailedEvent(sb, model);
        }

        // Failure handler step completed events
        if (model.HasFailureHandlers)
        {
            EmitFailureHandlerEvents(sb, model, model.FailureHandlers!);

            // Workflow Failed event with full exception context
            sb.AppendLine();
            EmitWorkflowFailedEvent(sb, model);
        }

        return sb.ToString();
    }

    private static void EmitEventInterface(StringBuilder sb, WorkflowModel model)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Marker interface for {model.WorkflowName} workflow events.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public partial interface I{model.PascalName}Event : IProgressEvent");
        sb.AppendLine("{");
        sb.AppendLine("}");
    }

    private static void EmitStartedEvent(StringBuilder sb, WorkflowModel model)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Event published when the {model.WorkflowName} workflow starts.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record {model.PascalName}Started(");
        sb.AppendLine("    Guid WorkflowId,");
        sb.AppendLine($"    {stateType} InitialState,");
        sb.AppendLine($"    DateTimeOffset Timestamp) : I{model.PascalName}Event;");
    }

    private static void EmitStepCompletedEvent(StringBuilder sb, WorkflowModel model, string stepName)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Event published when the {stepName} step completes.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record {stepName}Completed(");
        sb.AppendLine("    [property: SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    Guid StepExecutionId,");
        sb.AppendLine($"    {stateType} UpdatedState,");
        sb.AppendLine("    double? Confidence,");
        sb.AppendLine($"    DateTimeOffset Timestamp) : I{model.PascalName}Event;");
    }

    private static void EmitValidationFailedEvent(StringBuilder sb, WorkflowModel model)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Event published when a validation guard fails in the {model.WorkflowName} workflow.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record {model.PascalName}ValidationFailed(");
        sb.AppendLine("    [property: SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    string StepName,");
        sb.AppendLine("    string ErrorMessage,");
        sb.AppendLine($"    DateTimeOffset Timestamp) : I{model.PascalName}Event;");
    }

    private static void EmitWorkflowFailedEvent(StringBuilder sb, WorkflowModel model)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Event published when the {model.WorkflowName} workflow fails.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine("/// This event captures the full exception context:");
        sb.AppendLine("/// <list type=\"bullet\">");
        sb.AppendLine("///   <item><description>FailedStepName - The step where the failure occurred</description></item>");
        sb.AppendLine("///   <item><description>ExceptionType - The type name of the exception</description></item>");
        sb.AppendLine("///   <item><description>ExceptionMessage - The exception message</description></item>");
        sb.AppendLine("///   <item><description>StackTrace - The exception stack trace</description></item>");
        sb.AppendLine("///   <item><description>Timestamp - When the failure occurred</description></item>");
        sb.AppendLine("/// </list>");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record {model.PascalName}Failed(");
        sb.AppendLine("    [property: SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    string FailedStepName,");
        sb.AppendLine("    string? ExceptionType,");
        sb.AppendLine("    string? ExceptionMessage,");
        sb.AppendLine("    string? StackTrace,");
        sb.AppendLine($"    DateTimeOffset Timestamp) : I{model.PascalName}Event;");
    }

    private static void EmitFailureHandlerEvents(StringBuilder sb, WorkflowModel model, IReadOnlyList<FailureHandlerModel> handlers)
    {
        foreach (var handler in handlers)
        {
            var sanitizedId = handler.HandlerId.Replace("-", "_");

            foreach (var stepName in handler.StepNames)
            {
                sb.AppendLine();
                EmitFailureHandlerStepCompletedEvent(sb, model, handler, stepName, sanitizedId);
            }
        }
    }

    private static void EmitFailureHandlerStepCompletedEvent(
        StringBuilder sb,
        WorkflowModel model,
        FailureHandlerModel handler,
        string stepName,
        string sanitizedId)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Event published when the {stepName} failure handler step completes.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial record FailureHandler_{sanitizedId}_{stepName}Completed(");
        sb.AppendLine("    [property: SagaIdentity] Guid WorkflowId,");
        sb.AppendLine("    Guid StepExecutionId,");
        sb.AppendLine($"    {stateType} UpdatedState,");
        sb.AppendLine($"    DateTimeOffset Timestamp) : I{model.PascalName}Event;");
    }

    /// <summary>
    /// Emits completed events for approval rejection and escalation steps.
    /// </summary>
    /// <param name="sb">The StringBuilder to append to.</param>
    /// <param name="model">The workflow model.</param>
    /// <param name="approvals">The list of approval models.</param>
    /// <param name="emittedStepEvents">HashSet tracking already emitted step events.</param>
    private static void EmitApprovalStepEvents(
        StringBuilder sb,
        WorkflowModel model,
        IReadOnlyList<ApprovalModel>? approvals,
        HashSet<string> emittedStepEvents)
    {
        if (approvals is null)
        {
            return;
        }

        foreach (var approval in approvals)
        {
            // Emit events for rejection steps
            if (approval.RejectionSteps is not null)
            {
                foreach (var step in approval.RejectionSteps)
                {
                    if (emittedStepEvents.Add(step.StepName))
                    {
                        sb.AppendLine();
                        EmitStepCompletedEvent(sb, model, step.StepName);
                    }
                }
            }

            // Emit events for escalation steps
            if (approval.EscalationSteps is not null)
            {
                foreach (var step in approval.EscalationSteps)
                {
                    if (emittedStepEvents.Add(step.StepName))
                    {
                        sb.AppendLine();
                        EmitStepCompletedEvent(sb, model, step.StepName);
                    }
                }
            }

            // Handle nested approvals recursively
            EmitApprovalStepEvents(sb, model, approval.NestedEscalationApprovals, emittedStepEvents);
        }
    }
}

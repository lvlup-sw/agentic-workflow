// -----------------------------------------------------------------------
// <copyright file="WorkerHandlerEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Text;

using Agentic.Workflow.Generators.Helpers;
using Agentic.Workflow.Generators.Models;
using Agentic.Workflow.Generators.Polyfills;

namespace Agentic.Workflow.Generators.Emitters;

/// <summary>
/// Emits Wolverine worker handler classes for workflow steps.
/// </summary>
/// <remarks>
/// Implements the "Muscle" part of the Brain &amp; Muscle pattern:
/// Workers execute steps (LLM calls, I/O) without holding saga database locks.
/// </remarks>
internal static class WorkerHandlerEmitter
{
    /// <summary>
    /// Generates the worker handler classes source code for the given workflow model.
    /// </summary>
    /// <param name="model">The workflow model containing step information.</param>
    /// <returns>The generated C# source code for the worker handler classes.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);

        // Collect unique step namespaces for usings
        var usings = new List<string>
        {
            "System",
            "System.CodeDom.Compiler",
            "System.Diagnostics",
            "System.Threading",
            "System.Threading.Tasks",
            "Agentic.Workflow.Steps",
            "Agentic.Workflow.Agents.Telemetry",
            "Microsoft.Extensions.Logging",
        };

        // Add step type namespaces from the model
        if (model.Steps is not null)
        {
            foreach (var step in model.Steps)
            {
                var ns = GetNamespaceFromTypeName(step.StepTypeName);
                if (!string.IsNullOrEmpty(ns) && !usings.Contains(ns))
                {
                    usings.Add(ns);
                }
            }
        }

        FileHeaderHelper.AppendUsings(sb, usings.ToArray());

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);
        sb.AppendLine();

        // Generate a handler class for each unique step type (not phase)
        // The same step type can appear in multiple phases (main flow + loop), but we only need one handler
        var emittedStepNames = new HashSet<string>(StringComparer.Ordinal);
        if (model.Steps is not null)
        {
            foreach (var step in model.Steps)
            {
                if (emittedStepNames.Add(step.StepName))
                {
                    EmitHandlerClass(sb, model, step);
                    sb.AppendLine();
                }
            }
        }
        else
        {
            // Fallback for models without Step collection - use StepNames directly
            foreach (var stepName in model.StepNames)
            {
                if (emittedStepNames.Add(stepName))
                {
                    EmitHandlerClassFromName(sb, model, stepName);
                    sb.AppendLine();
                }
            }
        }

        // Generate handler classes for branch case steps
        // These steps execute conditionally based on discriminator
        if (model.Branches is not null)
        {
            foreach (var branch in model.Branches)
            {
                foreach (var branchCase in branch.Cases)
                {
                    foreach (var stepName in branchCase.StepNames)
                    {
                        if (emittedStepNames.Add(stepName))
                        {
                            EmitHandlerClassFromName(sb, model, stepName);
                            sb.AppendLine();
                        }
                    }
                }
            }
        }

        return sb.ToString();
    }

    /// <summary>
    /// Extracts the namespace from a fully qualified type name.
    /// </summary>
    private static string GetNamespaceFromTypeName(string typeName)
    {
        var lastDot = typeName.LastIndexOf('.');
        return lastDot > 0 ? typeName.Substring(0, lastDot) : string.Empty;
    }

    private static void EmitHandlerClass(StringBuilder sb, WorkflowModel model, StepModel step)
    {
        EmitHandlerClassCore(sb, model, step.StepName);
    }

    private static void EmitHandlerClassFromName(StringBuilder sb, WorkflowModel model, string stepName)
    {
        EmitHandlerClassCore(sb, model, stepName);
    }

    private static void EmitHandlerClassCore(StringBuilder sb, WorkflowModel model, string stepName)
    {
        var workerCommandName = $"Execute{stepName}WorkerCommand";
        var completedEventName = $"{stepName}Completed";
        var handlerClassName = $"{stepName}Handler";
        var stateType = model.StateTypeName ?? "object";

        // XML documentation
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Worker handler for the {stepName} step.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("/// <para>");
        sb.AppendLine("/// This handler implements the \"Muscle\" part of the Brain &amp; Muscle pattern.");
        sb.AppendLine("/// It executes step logic (LLM calls, I/O operations) without holding saga database locks,");
        sb.AppendLine("/// enabling better throughput and avoiding lock contention in high-volume scenarios.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// <para>");
        sb.AppendLine("/// The handler wraps step execution with OpenTelemetry tracing and structured logging");
        sb.AppendLine("/// for production observability. Exceptions are logged with full context before re-throwing");
        sb.AppendLine("/// to allow Wolverine's retry policies to handle transient failures.");
        sb.AppendLine("/// </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial class {handlerClassName}(");
        sb.AppendLine($"    {stepName} step,");
        sb.AppendLine($"    ILogger<{handlerClassName}> logger)");
        sb.AppendLine("{");

        // Private fields from primary constructor
        sb.AppendLine($"    private readonly {stepName} _step = step;");
        sb.AppendLine($"    private readonly ILogger<{handlerClassName}> _logger = logger;");
        sb.AppendLine();

        // Handle method
        EmitHandleMethod(sb, model, stepName, workerCommandName, completedEventName, stateType);

        sb.AppendLine("}");
    }

    private static void EmitHandleMethod(
        StringBuilder sb,
        WorkflowModel model,
        string stepName,
        string workerCommandName,
        string completedEventName,
        string stateType)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Handles the {workerCommandName} by executing the step.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    /// <param name=\"command\">The worker command with workflow state.</param>");
        sb.AppendLine($"    /// <param name=\"ct\">The cancellation token.</param>");
        sb.AppendLine($"    /// <returns>The completion event for saga routing via cascading.</returns>");
        sb.AppendLine("    /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"command\"/> is null.</exception>");
        sb.AppendLine($"    public async Task<{completedEventName}> Handle(");
        sb.AppendLine($"        {workerCommandName} command,");
        sb.AppendLine("        CancellationToken ct)");
        sb.AppendLine("    {");
        sb.AppendLine("        ArgumentNullException.ThrowIfNull(command, nameof(command));");
        sb.AppendLine();
        sb.AppendLine($"        _logger.LogDebug(");
        sb.AppendLine($"            \"Executing step {{StepName}} for workflow {{WorkflowId}}\",");
        sb.AppendLine($"            \"{stepName}\",");
        sb.AppendLine("            command.WorkflowId);");
        sb.AppendLine();
        sb.AppendLine($"        using var activity = WorkflowTelemetry.StartStepSpan(\"{stepName}\", command.WorkflowId);");
        sb.AppendLine("        var sw = Stopwatch.StartNew();");
        sb.AppendLine();
        sb.AppendLine("        try");
        sb.AppendLine("        {");
        sb.AppendLine($"            var stepContext = StepContext.Create(command.WorkflowId, \"{stepName}\", \"{stepName}\");");
        sb.AppendLine("            var result = await _step.ExecuteAsync(command.State, stepContext, ct);");
        sb.AppendLine();
        sb.AppendLine("            sw.Stop();");
        sb.AppendLine("            activity?.SetStatus(ActivityStatusCode.Ok);");
        sb.AppendLine("            activity?.SetTag(\"step.duration_ms\", sw.ElapsedMilliseconds);");
        sb.AppendLine("            activity?.SetTag(\"step.confidence\", result.Confidence);");
        sb.AppendLine();
        sb.AppendLine($"            _logger.LogDebug(");
        sb.AppendLine($"                \"Step {{StepName}} completed for workflow {{WorkflowId}} in {{ElapsedMs}}ms\",");
        sb.AppendLine($"                \"{stepName}\",");
        sb.AppendLine("                command.WorkflowId,");
        sb.AppendLine("                sw.ElapsedMilliseconds);");
        sb.AppendLine();
        sb.AppendLine("            // Return cascading: Wolverine routes via [SagaIdentity] on the event");
        sb.AppendLine($"            return new {completedEventName}(");
        sb.AppendLine("                command.WorkflowId,");
        sb.AppendLine("                command.StepExecutionId,");
        sb.AppendLine("                result.UpdatedState,");
        sb.AppendLine("                result.Confidence,");
        sb.AppendLine("                DateTimeOffset.UtcNow);");
        sb.AppendLine("        }");
        sb.AppendLine("        catch (Exception ex)");
        sb.AppendLine("        {");
        sb.AppendLine("            sw.Stop();");
        sb.AppendLine("            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);");
        sb.AppendLine("            activity?.SetTag(\"step.duration_ms\", sw.ElapsedMilliseconds);");
        sb.AppendLine("            activity?.SetTag(\"error.type\", ex.GetType().Name);");
        sb.AppendLine();
        sb.AppendLine($"            _logger.LogError(");
        sb.AppendLine("                ex,");
        sb.AppendLine($"                \"Step {{StepName}} failed for workflow {{WorkflowId}} after {{ElapsedMs}}ms: {{ErrorMessage}}\",");
        sb.AppendLine($"                \"{stepName}\",");
        sb.AppendLine("                command.WorkflowId,");
        sb.AppendLine("                sw.ElapsedMilliseconds,");
        sb.AppendLine("                ex.Message);");
        sb.AppendLine();
        sb.AppendLine("            // Re-throw to let Wolverine handle retry/dead-letter");
        sb.AppendLine("            throw;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }
}
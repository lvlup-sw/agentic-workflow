// -----------------------------------------------------------------------
// <copyright file="ContextAssemblerEmitter.cs" company="Levelup Software">
// Copyright (c) Levelup Software. All rights reserved.
// </copyright>
// -----------------------------------------------------------------------

using System.Collections.Generic;
using System.Text;

using Agentic.Workflow.Generators.Helpers;
using Agentic.Workflow.Generators.Models;
using Agentic.Workflow.Generators.Polyfills;

namespace Agentic.Workflow.Generators.Emitters;

/// <summary>
/// Emits context assembler classes for workflow steps that have context configuration.
/// </summary>
/// <remarks>
/// Context assemblers implement <c>IContextAssembler{TState}</c> and are responsible
/// for assembling runtime context from multiple sources (state, RAG retrieval, literals).
/// </remarks>
internal static class ContextAssemblerEmitter
{
    /// <summary>
    /// Generates the context assembler source code for all steps with context in the workflow.
    /// </summary>
    /// <param name="model">The workflow model containing step information.</param>
    /// <returns>The generated C# source code for the context assembler classes.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="model"/> is null.</exception>
    public static string Emit(WorkflowModel model)
    {
        ThrowHelper.ThrowIfNull(model, nameof(model));

        var sb = new StringBuilder();

        // File header
        FileHeaderHelper.AppendAutoGeneratedHeader(sb);
        FileHeaderHelper.AppendUsings(
            sb,
            "System",
            "System.CodeDom.Compiler",
            "System.Collections.Generic",
            "System.Threading",
            "System.Threading.Tasks",
            "Agentic.Workflow.Agents.Models",
            "Agentic.Workflow.Rag",
            "Agentic.Workflow.Steps");

        // Namespace
        FileHeaderHelper.AppendNamespace(sb, model.Namespace);

        // Find steps with context and generate assemblers for each
        var stepsWithContext = GetStepsWithContext(model);
        var isFirst = true;

        foreach (var step in stepsWithContext)
        {
            if (!isFirst)
            {
                sb.AppendLine();
            }

            EmitContextAssembler(sb, model, step);
            isFirst = false;
        }

        return sb.ToString();
    }

    private static IReadOnlyList<StepModel> GetStepsWithContext(WorkflowModel model)
    {
        if (model.Steps is null)
        {
            return [];
        }

        var stepsWithContext = new List<StepModel>();
        foreach (var step in model.Steps)
        {
            if (step.Context is not null && step.Context.Sources.Count > 0)
            {
                stepsWithContext.Add(step);
            }
        }

        return stepsWithContext;
    }

    private static void EmitContextAssembler(StringBuilder sb, WorkflowModel model, StepModel step)
    {
        var stateType = model.StateTypeName ?? "object";
        var className = $"{step.StepName}ContextAssembler";

        // XML documentation
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Assembles runtime context for the {step.StepName} step.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[GeneratedCode(\"Agentic.Workflow.Generators\", \"1.0.0\")]");
        sb.AppendLine($"public sealed partial class {className} : IContextAssembler<{stateType}>");
        sb.AppendLine("{");

        // Constructor with dependencies
        EmitConstructorAndDependencies(sb, step);

        // AssembleAsync method
        EmitAssembleAsyncMethod(sb, model, step);

        sb.AppendLine("}");
    }

    private static void EmitConstructorAndDependencies(StringBuilder sb, StepModel step)
    {
        // Collect retrieval sources to inject collection services
        var retrievalSources = new List<RetrievalContextSourceModel>();
        foreach (var source in step.Context!.Sources)
        {
            if (source is RetrievalContextSourceModel retrieval)
            {
                retrievalSources.Add(retrieval);
            }
        }

        if (retrievalSources.Count > 0)
        {
            // Field declarations
            foreach (var retrieval in retrievalSources)
            {
                var fieldName = $"_{ToCamelCase(retrieval.CollectionTypeName)}Collection";
                sb.AppendLine($"    private readonly IVectorSearchAdapter<{retrieval.CollectionTypeName}> {fieldName};");
            }

            sb.AppendLine();

            // Constructor
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Initializes a new instance of the <see cref=\"{step.StepName}ContextAssembler\"/> class.");
            sb.AppendLine($"    /// </summary>");
            sb.Append($"    public {step.StepName}ContextAssembler(");

            var first = true;
            foreach (var retrieval in retrievalSources)
            {
                if (!first)
                {
                    sb.Append(", ");
                }

                var paramName = $"{ToCamelCase(retrieval.CollectionTypeName)}Collection";
                sb.Append($"IVectorSearchAdapter<{retrieval.CollectionTypeName}> {paramName}");
                first = false;
            }

            sb.AppendLine(")");
            sb.AppendLine("    {");

            foreach (var retrieval in retrievalSources)
            {
                var fieldName = $"_{ToCamelCase(retrieval.CollectionTypeName)}Collection";
                var paramName = $"{ToCamelCase(retrieval.CollectionTypeName)}Collection";
                sb.AppendLine($"        {fieldName} = {paramName};");
            }

            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static void EmitAssembleAsyncMethod(StringBuilder sb, WorkflowModel model, StepModel step)
    {
        var stateType = model.StateTypeName ?? "object";

        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine($"    public async Task<AssembledContext> AssembleAsync({stateType} state, StepContext stepContext, CancellationToken cancellationToken)");
        sb.AppendLine("    {");
        sb.AppendLine("        var contextBuilder = new AssembledContextBuilder();");
        sb.AppendLine();

        foreach (var source in step.Context!.Sources)
        {
            switch (source)
            {
                case LiteralContextSourceModel literal:
                    EmitLiteralSource(sb, literal);
                    break;

                case StateContextSourceModel stateSource:
                    EmitStateSource(sb, stateSource);
                    break;

                case RetrievalContextSourceModel retrieval:
                    EmitRetrievalSource(sb, retrieval);
                    break;
            }
        }

        sb.AppendLine();
        sb.AppendLine("        return contextBuilder.Build();");
        sb.AppendLine("    }");
    }

    private static void EmitLiteralSource(StringBuilder sb, LiteralContextSourceModel literal)
    {
        // Escape the string for C# verbatim string
        var escapedValue = EscapeStringForCSharp(literal.Value);
        sb.AppendLine($"        // Literal context");
        sb.AppendLine($"        contextBuilder.AddLiteralContext(\"{escapedValue}\");");
    }

    private static void EmitStateSource(StringBuilder sb, StateContextSourceModel stateSource)
    {
        sb.AppendLine($"        // State context: {stateSource.PropertyPath}");
        sb.AppendLine($"        contextBuilder.AddStateContext(\"{stateSource.PropertyPath}\", {stateSource.AccessExpression});");
    }

    private static void EmitRetrievalSource(StringBuilder sb, RetrievalContextSourceModel retrieval)
    {
        var fieldName = $"_{ToCamelCase(retrieval.CollectionTypeName)}Collection";
        var resultsVarName = $"{ToCamelCase(retrieval.CollectionTypeName)}Results";

        sb.AppendLine($"        // Retrieval context from {retrieval.CollectionTypeName}");

        // Build the query
        string queryExpr;
        if (retrieval.LiteralQuery is not null)
        {
            queryExpr = $"\"{EscapeStringForCSharp(retrieval.LiteralQuery)}\"";
        }
        else if (retrieval.QueryExpression is not null)
        {
            queryExpr = $"({retrieval.QueryExpression})(state)";
        }
        else
        {
            queryExpr = "string.Empty";
        }

        sb.AppendLine($"        var {resultsVarName} = await {fieldName}.SearchAsync(");
        sb.AppendLine($"            {queryExpr},");
        sb.AppendLine($"            topK: {retrieval.TopK},");
        sb.AppendLine($"            minRelevance: {retrieval.MinRelevance}m,");
        sb.AppendLine($"            cancellationToken: cancellationToken);");
        sb.AppendLine($"        contextBuilder.AddRetrievalContext(\"{retrieval.CollectionTypeName}\", {resultsVarName});");
    }

    private static string ToCamelCase(string pascalCase)
    {
        if (string.IsNullOrEmpty(pascalCase))
        {
            return pascalCase;
        }

        return char.ToLowerInvariant(pascalCase[0]) + pascalCase.Substring(1);
    }

    private static string EscapeStringForCSharp(string value)
    {
        return value
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}


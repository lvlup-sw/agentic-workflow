name: Project Automation

on:
  issues:
    types: [opened, labeled, unlabeled, closed, reopened]
  pull_request:
    types: [opened, ready_for_review, closed]
  issue_comment:
    types: [created]
  push:
    branches: [main]
    paths:
      - '.github/labels.yml'
    tags:
      - 'v*'
  schedule:
    - cron: '0 9 * * 1'  # Weekly stale check, Monday 9am UTC

env:
  PROJECT_NUMBER: 3

jobs:
  # ============================================================
  # LABEL SYNC: Sync labels from labels.yml on push
  # ============================================================
  label-sync:
    if: github.event_name == 'push' && !startsWith(github.ref, 'refs/tags/')
    uses: lvlup-sw/.github/.github/workflows/label-sync.yml@main
    secrets: inherit

  # ============================================================
  # AUTO-TRIAGE: Label new issues based on content
  # ============================================================
  auto-triage:
    if: github.event_name == 'issues' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Auto-label based on title/body
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const text = `${issue.title} ${issue.body}`.toLowerCase();
            const labels = ['status:triage'];

            // Type detection
            if (text.match(/bug|error|fail|broken|crash|issue/)) {
              labels.push('type:bug');
            } else if (text.match(/feature|add|implement|support|enhance/)) {
              labels.push('type:feature');
            } else if (text.match(/doc|readme|typo|clarif/)) {
              labels.push('type:docs');
            } else if (text.match(/\?|how|what|why|question/)) {
              labels.push('type:question');
            }

            // Scope detection for agentic-workflow
            if (text.match(/workflow|step|state|execution/)) {
              labels.push('scope:workflow');
            }
            if (text.match(/agent|orchestrat|subagent/)) {
              labels.push('scope:agents');
            }
            if (text.match(/rag|embedding|vector|knowledge/)) {
              labels.push('scope:rag');
            }
            if (text.match(/infrastructure|logging|telemetry|config/)) {
              labels.push('scope:infrastructure');
            }
            if (text.match(/generator|source.gen|codegen/)) {
              labels.push('scope:generators');
            }

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: labels
            });

  # ============================================================
  # AUTO-ASSIGN: Assign PR author as assignee
  # ============================================================
  auto-assign-author:
    if: github.event_name == 'pull_request' && github.event.action == 'opened' && github.event.pull_request.user.type != 'Bot'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: Assign PR author
        run: gh pr edit "$PR_URL" --add-assignee "$AUTHOR"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          AUTHOR: ${{ github.event.pull_request.user.login }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================
  # PROJECT SYNC: Add issues/PRs to project board
  # ============================================================
  project-sync:
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened')
    runs-on: ubuntu-latest
    steps:
      - name: Add to project
        uses: actions/add-to-project@v1.0.2
        with:
          project-url: https://github.com/orgs/lvlup-sw/projects/${{ env.PROJECT_NUMBER }}
          github-token: ${{ secrets.PROJECT_TOKEN }}

  # ============================================================
  # PROJECT FIELD INIT: Set Priority, Type, Iteration on new items
  # ============================================================
  project-field-init:
    needs: project-sync
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened')
    runs-on: ubuntu-latest
    steps:
      - name: Initialize project fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            // 1. Get item content (issue or PR)
            const content = context.payload.issue || context.payload.pull_request;
            const contentId = content.node_id;
            const labels = content.labels?.map(l => l.name) || [];
            const body = (content.body || '').toLowerCase();

            // 2. Determine field values
            // Map labels to project Priority options (P0=urgent, P1=high, P2=normal)
            const priorityMap = { 'priority:high': 'P0', 'priority:low': 'P2' };
            const priority = labels.find(l => priorityMap[l])
              ? priorityMap[labels.find(l => priorityMap[l])]
              : 'P2';

            // 3. Check if should assign to current iteration (P0/urgent)
            const urgentKeywords = /urgent|critical|blocker|p0|asap|emergency/;
            const isUrgent = labels.includes('priority:high') && urgentKeywords.test(body);

            // 4. Query project fields
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 20) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options { id name }
                        }
                        ... on ProjectV2IterationField {
                          id
                          name
                          configuration {
                            iterations { id title startDate duration }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const { organization } = await github.graphql(projectQuery, {
              org: context.repo.owner,
              number: parseInt(process.env.PROJECT_NUMBER)
            });

            const project = organization.projectV2;
            const fields = project.fields.nodes.filter(f => f.id);

            // 5. Find project item
            const itemQuery = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content { ... on Issue { id } ... on PullRequest { id } }
                      }
                    }
                  }
                }
              }
            `;

            const itemData = await github.graphql(itemQuery, { projectId: project.id });
            const item = itemData.node.items.nodes.find(i => i.content?.id === contentId);

            if (!item) {
              console.log('Item not found in project');
              return;
            }

            // 6. Update fields
            const mutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: ProjectV2FieldValue!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: $value
                }) { projectV2Item { id } }
              }
            `;

            // Set Priority
            const priorityField = fields.find(f => f.name === 'Priority');
            if (priorityField) {
              const option = priorityField.options.find(o => o.name === priority);
              if (option) {
                await github.graphql(mutation, {
                  projectId: project.id,
                  itemId: item.id,
                  fieldId: priorityField.id,
                  value: { singleSelectOptionId: option.id }
                });
                console.log(`Set Priority: ${priority}`);
              }
            }

            // Set Iteration (only if urgent)
            if (isUrgent) {
              const iterField = fields.find(f => f.name === 'Sprint' || f.name === 'Iteration');
              if (iterField?.configuration?.iterations) {
                const now = new Date();
                const currentIter = iterField.configuration.iterations.find(iter => {
                  const start = new Date(iter.startDate);
                  const end = new Date(start.getTime() + iter.duration * 7 * 24 * 60 * 60 * 1000);
                  return now >= start && now < end;
                });
                if (currentIter) {
                  await github.graphql(mutation, {
                    projectId: project.id,
                    itemId: item.id,
                    fieldId: iterField.id,
                    value: { iterationId: currentIter.id }
                  });
                  console.log(`Set Iteration: ${currentIter.title} (urgent item)`);
                }
              }
            }

            // 7. Auto-link parent issue if referenced in body
            // Patterns: "Parent: #123", "Parent #123", "Sub-issue of #123", "Child of #123"
            const parentMatch = content.body?.match(/(?:parent:?\s*#|sub-?issue\s+of\s+#|child\s+of\s+#)(\d+)/i);
            if (parentMatch && context.payload.issue) {
              const parentNumber = parseInt(parentMatch[1]);
              console.log(`Detected parent reference: #${parentNumber}`);

              try {
                // Get parent issue node ID
                const parentIssue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: parentNumber
                });

                // Add as sub-issue using GraphQL
                const addSubIssueMutation = `
                  mutation($parentId: ID!, $childId: ID!) {
                    addSubIssue(input: {
                      issueId: $parentId
                      subIssueId: $childId
                    }) {
                      issue { id }
                      subIssue { id }
                    }
                  }
                `;

                await github.graphql(addSubIssueMutation, {
                  parentId: parentIssue.data.node_id,
                  childId: contentId
                });

                console.log(`Linked as sub-issue of #${parentNumber}`);
              } catch (err) {
                console.log(`Failed to link parent: ${err.message}`);
              }
            }

            console.log('Field initialization complete');

  # ============================================================
  # PROJECT STATUS: Update project board status on events
  # ============================================================
  project-status-update:
    if: |
      github.event_name == 'issues' ||
      github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Update project status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const statusMap = {
              'issues.closed': 'Done',
              'issues.reopened': 'Backlog',
              'pull_request.ready_for_review': 'In Review',
              'pull_request.closed': context.payload.pull_request?.merged ? 'Done' : 'Backlog'
            };

            const eventKey = `${context.eventName}.${context.payload.action}`;
            const newStatus = statusMap[eventKey];

            if (!newStatus) return;

            const contentId = context.payload.issue?.node_id || context.payload.pull_request?.node_id;
            if (!contentId) return;

            // Get project and field info
            const projectQuery = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    field(name: "Status") {
                      ... on ProjectV2SingleSelectField {
                        id
                        options { id name }
                      }
                    }
                  }
                }
              }
            `;

            const projectData = await github.graphql(projectQuery, {
              org: context.repo.owner,
              number: parseInt(process.env.PROJECT_NUMBER)
            });

            const project = projectData.organization.projectV2;
            const statusField = project.field;
            const targetOption = statusField.options.find(o => o.name === newStatus);

            if (!targetOption) {
              console.log(`Status option "${newStatus}" not found`);
              return;
            }

            // Find item in project
            const itemQuery = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    items(first: 100) {
                      nodes {
                        id
                        content { ... on Issue { id } ... on PullRequest { id } }
                      }
                    }
                  }
                }
              }
            `;

            const itemData = await github.graphql(itemQuery, {
              projectId: project.id
            });

            const item = itemData.node.items.nodes.find(
              i => i.content?.id === contentId
            );

            if (!item) {
              console.log('Item not found in project');
              return;
            }

            // Update status
            const mutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: { singleSelectOptionId: $optionId }
                }) { projectV2Item { id } }
              }
            `;

            await github.graphql(mutation, {
              projectId: project.id,
              itemId: item.id,
              fieldId: statusField.id,
              optionId: targetOption.id
            });

            console.log(`Updated status to: ${newStatus}`);

  # ============================================================
  # STALE MANAGEMENT: Mark and close inactive issues
  # ============================================================
  stale:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - uses: actions/stale@v9
        with:
          stale-issue-message: |
            This issue has been automatically marked as stale because it has not had
            recent activity. It will be closed in 14 days if no further activity occurs.
          close-issue-message: |
            This issue was closed because it has been stale for 14 days with no activity.
            Feel free to reopen if this is still relevant.
          stale-issue-label: 'status:stale'
          exempt-issue-labels: 'priority:high,status:blocked'
          days-before-stale: 60
          days-before-close: 14
          operations-per-run: 30

  # ============================================================
  # PR AUTOMATION: Auto-merge Renovate PRs
  # ============================================================
  auto-merge-renovate:
    if: |
      github.event_name == 'pull_request' &&
      github.event.pull_request.user.login == 'renovate[bot]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Enable auto-merge for Renovate PRs
        run: gh pr merge --auto --squash "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================================
  # RELEASE AUTOMATION: Generate changelog and release
  # ============================================================
  release:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        uses: orhun/git-cliff-action@v3
        with:
          config: .github/cliff.toml
          args: --latest --strip header

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          body: ${{ steps.changelog.outputs.content }}
          generate_release_notes: false
